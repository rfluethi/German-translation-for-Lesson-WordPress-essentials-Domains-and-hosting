name: Create and upload ZIP files for release (DISABLED BACKUP)

on:
  # DISABLED: conflicts with main release workflow
  # release:
  #   types: [created]
  # workflow_dispatch:

permissions:
  contents: write
  packages: write
  actions: read

jobs:
  zip_and_upload:
    runs-on: ubuntu-latest
    steps:
      # First: Checkout WITHOUT LFS to get the basic repository
      - name: Checkout repository (basic)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # Install Git LFS manually and configure authentication
      - name: Setup Git LFS with proper authentication
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Install git-lfs if not available
          if ! command -v git-lfs &> /dev/null; then
            curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
            sudo apt-get install git-lfs
          fi
          
          echo "Git LFS version: $(git lfs version)"
          
          # Configure git with token for LFS access
          git config --global credential.helper store
          echo "https://x-access-token:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
          
          # Install git-lfs hooks
          git lfs install
          
          # Show LFS environment for debugging
          echo "=== LFS Environment ==="
          git lfs env

      # Alternative approach: Use git-lfs-authenticate for proper token handling
      - name: Authenticate and download LFS files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Set up authentication for LFS
          git config lfs.https://github.com/${{ github.repository }}.git/info/lfs.access basic
          
          # Try to download all LFS files with multiple methods
          echo "=== Attempting LFS download methods ==="
          
          # Method 1: Standard LFS pull
          echo "Method 1: git lfs pull"
          git lfs pull --include="*" || echo "Method 1 failed"
          
          # Method 2: Fetch and checkout
          echo "Method 2: git lfs fetch + checkout"
          git lfs fetch --all || echo "LFS fetch failed"
          git lfs checkout || echo "LFS checkout failed"
          
          # Method 3: Force re-download
          echo "Method 3: Force re-download"
          git lfs pull --include="*" --exclude="" || echo "Method 3 failed"

      # Critical: Verify that LFS files are actually downloaded as real files
      - name: Verify LFS files are real (not pointers)
        run: |
          echo "=== CRITICAL: Verifying LFS files are real content ==="
          
          # Function to check if file is LFS pointer
          check_lfs_file() {
            local file="$1"
            if [ ! -f "$file" ]; then
              echo "‚ùå File not found: $file"
              return 1
            fi
            
            local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file")
            local file_type=$(file "$file")
            
            echo "Checking: $file"
            echo "  Size: $size bytes"
            echo "  Type: $file_type"
            
            # Check if it's a text file (potential pointer)
            if echo "$file_type" | grep -i "text" > /dev/null; then
              echo "  WARNING: Appears to be text file"
              echo "  First 3 lines:"
              head -3 "$file"
              
              # Check if it contains LFS pointer keywords
              if head -5 "$file" | grep -E "(version|size|oid)" > /dev/null; then
                echo "  ‚ùå FAILURE: This is an LFS pointer file!"
                return 1
              fi
            fi
            
            # Check minimum size (LFS pointers are usually < 200 bytes)
            if [ "$size" -lt 1000 ]; then
              echo "  ‚ùå FAILURE: File too small ($size bytes), likely a pointer!"
              return 1
            fi
            
            echo "  ‚úÖ SUCCESS: File appears to be real content"
            return 0
          }
          
          # Check critical files
          critical_files=(
            "media/video/video-v-0-02-00.mp4"
          )
          
          failed_files=()
          for file in "${critical_files[@]}"; do
            if ! check_lfs_file "$file"; then
              failed_files+=("$file")
            fi
          done
          
          # If any files failed, try alternative download methods
          if [ ${#failed_files[@]} -gt 0 ]; then
            echo "‚ùå Some files are still pointers. Trying alternative methods..."
            
            # Alternative: Download via GitHub API
            echo "=== Trying GitHub API download ==="
            for file in "${failed_files[@]}"; do
              echo "Downloading $file via GitHub API..."
              # This approach downloads the raw file content
              curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                   -H "Accept: application/vnd.git-lfs+json" \
                   -L "https://api.github.com/repos/${{ github.repository }}/git/blobs/$(git rev-parse HEAD:$file)" \
                   -o "$file.tmp" || echo "API download failed for $file"
              
              if [ -f "$file.tmp" ] && [ $(stat -c%s "$file.tmp" 2>/dev/null || stat -f%z "$file.tmp") -gt 1000 ]; then
                mv "$file.tmp" "$file"
                echo "‚úÖ Successfully downloaded $file via API"
              else
                rm -f "$file.tmp"
                echo "‚ùå API download failed for $file"
              fi
            done
          fi
          
          # Final verification
          echo "=== Final verification ==="
          all_good=true
          for file in "${critical_files[@]}"; do
            if ! check_lfs_file "$file"; then
              all_good=false
            fi
          done
          
          if [ "$all_good" = false ]; then
            echo "‚ùå CRITICAL FAILURE: Some LFS files are still pointers!"
            echo "This will result in ZIP files with pointer content instead of real files."
            exit 1
          fi
          
      # Alternative approach: Download LFS files directly via GitHub API
      - name: Download LFS files via GitHub API
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== Downloading LFS files via GitHub API ==="
          
          # Function to download LFS file via API
          download_lfs_file() {
            local file_path="$1"
            echo "Downloading LFS file: $file_path"
            
            # Get the LFS pointer content first
            if [ ! -f "$file_path" ]; then
              echo "‚ùå File not found: $file_path"
              return 1
            fi
            
            # Check if it's a pointer file
            if head -5 "$file_path" | grep -E "version.*https://git-lfs.github.com" > /dev/null; then
              echo "üìç Detected LFS pointer file"
              
              # Extract OID from pointer file
              local oid=$(grep "oid sha256:" "$file_path" | cut -d: -f2 | tr -d ' ')
              local size=$(grep "size " "$file_path" | cut -d' ' -f2)
              
              echo "  OID: $oid"
              echo "  Size: $size bytes"
              
              # Download the actual file content from GitHub LFS
              local lfs_url="https://github.com/${{ github.repository }}.git/info/lfs/objects/batch"
              
              # Create the batch request
              local batch_request=$(cat <<EOF
{
  "operation": "download",
  "transfers": ["basic"],
  "objects": [
    {
      "oid": "$oid",
      "size": $size
    }
  ]
}
EOF
)
              
              echo "  Requesting download URL..."
              local response=$(curl -s -X POST \
                -H "Accept: application/vnd.git-lfs+json" \
                -H "Content-Type: application/vnd.git-lfs+json" \
                -H "Authorization: token $GITHUB_TOKEN" \
                -d "$batch_request" \
                "$lfs_url")
              
              # Extract download URL from response
              local download_url=$(echo "$response" | grep -o '"href":"[^"]*' | cut -d'"' -f4 | head -1)
              
              if [ -n "$download_url" ]; then
                echo "  Download URL found, downloading..."
                if curl -L -o "$file_path.tmp" "$download_url"; then
                  local downloaded_size=$(stat -c%s "$file_path.tmp" 2>/dev/null || stat -f%z "$file_path.tmp")
                  if [ "$downloaded_size" -gt 1000 ]; then
                    mv "$file_path.tmp" "$file_path"
                    echo "  ‚úÖ Successfully downloaded $file_path ($downloaded_size bytes)"
                    return 0
                  else
                    echo "  ‚ùå Downloaded file too small: $downloaded_size bytes"
                    rm -f "$file_path.tmp"
                  fi
                else
                  echo "  ‚ùå Download failed"
                  rm -f "$file_path.tmp"
                fi
              else
                echo "  ‚ùå No download URL found in response"
                echo "  Response: $response"
              fi
            else
              echo "  ‚úÖ File is already real content (not a pointer)"
              return 0
            fi
            
            return 1
          }
          
          # Download critical LFS files
          critical_files=(
            "media/video/video-v-0-02-00.mp4"
          )
          
          for file in "${critical_files[@]}"; do
            download_lfs_file "$file" || echo "Failed to download $file"
          done

      # Final verification of all files before ZIP creation
      - name: Final verification before ZIP creation
        run: |
          echo "=== Final verification of all files ==="
          
          # Verify all critical files
          critical_files=(
            "media/video/video-v-0-02-00.mp4"
          )
          
          all_verified=true
          
          for file in "${critical_files[@]}"; do
            if [ -f "$file" ]; then
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file")
              file_type=$(file "$file")
              
              echo "File: $file"
              echo "  Size: $size bytes"
              echo "  Type: $file_type"
              
              # Check if still a pointer
              if [ "$size" -lt 1000 ] || echo "$file_type" | grep -i "text" > /dev/null; then
                echo "  ‚ùå STILL A POINTER FILE!"
                head -5 "$file"
                all_verified=false
              else
                echo "  ‚úÖ Real file content verified"
              fi
            else
              echo "‚ùå File not found: $file"
              all_verified=false
            fi
          done
          
          if [ "$all_verified" = false ]; then
            echo "‚ùå CRITICAL: Some files are still pointers or missing!"
            echo "Aborting to prevent ZIP files with pointer content."
            exit 1
          fi
          
          echo "‚úÖ All files verified - proceeding with ZIP creation"
      - name: List repository structure
        run: |
          echo "Current directory content:"
          ls -la
          echo "\nDocs directory content (if exists):"
          ls -la docs || echo "docs directory not found"
          echo "\nMedia directory content:"
          ls -la media/video || echo "media/video directory not found"
          echo "\nSource assets directory content:"
          ls -la src/assets/video || echo "src/assets/video directory not found"

      # Verify LFS files are properly downloaded
      - name: Verify LFS files
        run: |
          echo "=== LFS files status ==="
          git lfs ls-files
          
          echo -e "\n=== Checking specific large files ==="
          echo "Large video file:"
          if [ -f "media/video/video-v-0-02-00.mp4" ]; then
            ls -lh media/video/video-v-0-02-00.mp4
            echo "File type: $(file media/video/video-v-0-02-00.mp4)"
            echo "File size: $(du -h media/video/video-v-0-02-00.mp4)"
            # Check if it's a pointer file or actual content
            if file media/video/video-v-0-02-00.mp4 | grep -q "text"; then
              echo "WARNING: This appears to be a pointer file!"
              echo "Content preview:"
              head -5 media/video/video-v-0-02-00.mp4
            else
              echo "SUCCESS: This appears to be the actual video file!"
            fi
          else
            echo "ERROR: media/video/video-v-0-02-00.mp4 not found"
          fi
          
          echo -e "\n=== Checking cmproj directory ==="
          if [ -d "src/assets/video/video-v-0-02-00.cmproj" ]; then
            echo "cmproj directory contents:"
            ls -la src/assets/video/video-v-0-02-00.cmproj/
            echo "Total size of cmproj directory:"
            du -sh src/assets/video/video-v-0-02-00.cmproj/
          else
            echo "ERROR: src/assets/video/video-v-0-02-00.cmproj directory not found"
          fi

      # Check LFS file size and content before zipping
      - name: Check LFS file size and content
        run: |
          echo "Checking file size and content for media/video/video-v-0-02-00.mp4:"
          ls -lh media/video/video-v-0-02-00.mp4 || echo "File not found"
          file media/video/video-v-0-02-00.mp4 || echo "File not found"
          echo "\nChecking if file is a pointer or actual file:"
          head -5 media/video/video-v-0-02-00.mp4 | cat || echo "File not found"
          echo "\nListing all files in media/video:"
          ls -lh media/video/

      # Force re-download of all LFS files if needed
      - name: Force download all LFS files
        run: |
          echo "=== Force downloading all LFS files ==="
          
          # Remove any existing LFS objects and re-download
          git lfs fetch --all --force
          
          # Pull all LFS files for current branch
          git lfs pull --include="*"
          
          # Checkout all LFS files
          git lfs checkout
          
          echo "=== Verifying critical files after force download ==="
          # Check if the main video file is properly downloaded
          if [ -f "media/video/video-v-0-02-00.mp4" ]; then
            file_type=$(file media/video/video-v-0-02-00.mp4)
            file_size=$(stat -f%z media/video/video-v-0-02-00.mp4 2>/dev/null || stat -c%s media/video/video-v-0-02-00.mp4)
            
            echo "Video file type: $file_type"
            echo "Video file size: $file_size bytes"
            
            if [ "$file_size" -lt 1000 ]; then
              echo "ERROR: File too small, likely a pointer file"
              echo "Content:"
              cat media/video/video-v-0-02-00.mp4
              exit 1
            else
              echo "SUCCESS: Video file appears to be downloaded correctly"
            fi
          fi

      # Create docs ZIP with better error handling
      - name: Create docs ZIP
        run: |
          mkdir -p zip
          if [ -d "docs" ]; then
            if [ "$(ls -A docs)" ]; then
              echo "Creating ZIP for documents..."
              zip -r zip/tutorial-docs.zip docs
              echo "docs_zip_created=true" >> $GITHUB_ENV
            else
              echo "Docs directory is empty. Skipping ZIP creation."
            fi
          else
            echo "Docs directory does not exist. Skipping ZIP creation."
          fi

      # Create assets ZIP with LFS support
      - name: Create assets ZIP
        run: |
          if [ -d "src" ]; then
            if [ "$(ls -A src)" ]; then
              echo "Creating ZIP for assets (including LFS files)..."
              
              # Verify LFS files before zipping
              echo "Verifying LFS files in src directory:"
              find src -name "*.mp4" -o -name "*.cmproj" -o -name "*.wav" -o -name "*.m4a" | while read file; do
                if [ -f "$file" ]; then
                  size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
                  echo "$file: $size bytes"
                  if [ "$size" -lt 1000 ]; then
                    echo "WARNING: $file might be a pointer file (size: $size bytes)"
                  fi
                fi
              done
              
              # Create the ZIP file
              zip -r zip/tutorial-assets.zip src
              echo "Assets ZIP created with LFS files included"
              
              # Verify ZIP contents
              echo "Assets ZIP file size: $(du -h zip/tutorial-assets.zip | cut -f1)"
            else
              echo "Source directory is empty. Skipping ZIP creation."
            fi
          else
            echo "Source directory does not exist. Skipping ZIP creation."
          fi

      # Create videos ZIP with LFS support
      - name: Create videos ZIP
        run: |
          if [ -d "media/video" ]; then
            if [ "$(ls -A media/video)" ]; then
              echo "Creating ZIP for videos (including LFS files)..."
              
              # Verify LFS files before zipping
              echo "Verifying LFS files in media/video directory:"
              find media/video -name "*.mp4" -o -name "*.mov" -o -name "*.avi" | while read file; do
                if [ -f "$file" ]; then
                  size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
                  echo "$file: $size bytes"
                  if [ "$size" -lt 1000 ]; then
                    echo "ERROR: $file appears to be a pointer file (size: $size bytes)"
                    echo "Content:"
                    head -3 "$file"
                    exit 1
                  fi
                fi
              done
              
              # Create the ZIP file
              zip -r zip/tutorial-videos.zip media/video
              echo "Videos ZIP created with LFS files included"
              
              # Verify ZIP contents
              echo "Videos ZIP file size: $(du -h zip/tutorial-videos.zip | cut -f1)"
            else
              echo "Video directory is empty. Skipping ZIP creation."
            fi
          else
            echo "Video directory does not exist. Skipping ZIP creation."
          fi

      # Create complete project ZIP with all LFS files
      - name: Create complete project ZIP
        run: |
          echo "Creating complete project ZIP with all LFS files..."
          
          # Final verification of critical LFS files
          echo "=== Final verification before creating complete ZIP ==="
          critical_files=(
            "media/video/video-v-0-02-00.mp4"
          )
          
          for file in "${critical_files[@]}"; do
            if [ -f "$file" ]; then
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
              echo "$file: $size bytes"
              if [ "$size" -lt 1000 ]; then
                echo "ERROR: $file is likely a pointer file!"
                exit 1
              fi
            else
              echo "WARNING: $file not found"
            fi
          done
          
          # Create complete ZIP excluding git and existing zip files
          zip -r zip/tutorial-complete.zip . -x '*.git*' 'zip/*' '.DS_Store' '*/.DS_Store'
          echo "Complete project ZIP created with all LFS files included"
          
          # Show final ZIP size
          echo "Complete ZIP file size: $(du -h zip/tutorial-complete.zip | cut -f1)"

      # Debug step: Show ZIP contents and sizes
      - name: List ZIP files
        run: |
          echo "ZIP directory content:"
          ls -lh zip/
          echo "\nZIP file sizes:"
          for zipfile in zip/*.zip; do
            echo "$(basename "$zipfile"): $(du -h "$zipfile" | cut -f1)"
          done

      # Debug step: Check ZIP contents for LFS files
      - name: Check ZIP contents for LFS files
        run: |
          echo "Checking ZIP contents for LFS files..."
          for zipfile in zip/*.zip; do
            echo "\n=== Contents of $(basename "$zipfile") ==="
            unzip -l "$zipfile" | grep -E "\.(mp4|wav|m4a|cmproj|moho)" | head -10
            echo "Total size: $(du -h "$zipfile" | cut -f1)"
          done

      # Upload ZIP files when triggered by a release
      - name: Upload to Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: zip/*.zip
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Upload ZIP files when manually triggered
      - name: Upload Artifact
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: tutorial-zips
          path: zip/*.zip
